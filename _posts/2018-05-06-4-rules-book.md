---
layout:     post
title:      "Reading: 4 Rules of Simple Design by Corey Haines"
date:       2018-05-06 20:14:00
summary:    "Lessons learned from a person who observed thousands of pairs doing Conway's Game of Life." 
categories: 4 rules simple design corey haines
---

This is my partly paraphrased version of the book, which focusses on points I found enlightening.  

### Think carefully about what a well-written test looks like
The example he gave was this:  

```ruby
def test_a_new_world_is_empty
    world = World.new
    assert_equal 0, world.living_cells.count
end
```  
This is a reasonable test, but if you look at the test name it doesn't reflect what the test code is doing. The code is looking inside the world and counting the living cells in it. We should let the test be a mirror of the description. A better test would look like this:  
  
```ruby
def test_a_new_world_is_empty
    world = World.new
    assert_true world.empty?
end
```  

We can now see a more intuitive API forming because of this change. The consumer of the World class no longer has to check the number of living cells inside the world to know that it is empty. Instead, they can simply call `empty?`.

### Detecting duplication
To know whether there is duplication of knowledge, we should ask ourselves what happens if we want to change something. What effort is required? How many places will we need to look at and change?  

If there are multiple places you need to change, think about the concept that is being duplicated. For example, if we have `x, y` representing locations in many different places, we should extract that out into a `Location` class. 

### Placing a new method
Sometimes it's not immediately clear where to put a piece of code. In Conway's, it's unclear where to place the logic to get neighbours.  
  
It could belong in `Cell` because it has knowledge of its location. However, `Cell` has other responsibilities like figuring out whether it's alive or dead in the next generation.  

If we think about it, getting neighbours is entirely dependant on **location** and nothing else. So naturally it makes sense for the neighbour logic to belong in the `Location` class.  

Another thing to think about is if we don't know where something belongs, it indicates that we have a concept that isn't expressed well in our system.  

### Testing state vs Testing behaviour





